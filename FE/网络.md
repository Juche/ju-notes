# 网络

[🔻 底部](#bottom)<a id="top">⚓</a>

- [网络](#网络)
  - [网页从输入网址到渲染完成经的过程](#网页从输入网址到渲染完成经的过程)
  - [TCP 传输的三次握手、四次挥手策略](#tcp-传输的三次握手四次挥手策略)
  - [HTTP 和 HTTPS，为什么 HTTPS 安全](#http-和-https为什么-https-安全)
  - [HTTP 常见的状态码](#http-常见的状态码)
  - [中断 ajax 请求](#中断-ajax-请求)
  - [get/post 的区别](#getpost-的区别)
  - [get 请求传参长度的误区、get 和 post 请求在缓存方面的区别](#get-请求传参长度的误区get-和-post-请求在缓存方面的区别)
  - [常见跨域的解决办法](#常见跨域的解决办法)

---

## 网页从输入网址到渲染完成经的过程

大致可以分为如下 7 步：

- 输入网址；
- 发送到 DNS 服务器，并获取域名对应的 web 服务器对应的 ip 地址；
- 与 web 服务器建立 TCP 连接；
- 浏览器向 web 服务器发送 http 请求；
- web 服务器响应请求，并返回指定 url 的数据（或错误信息，或重定向的新的 url 地址）；
- 浏览器下载 web 服务器返回的数据及解析 html 源文件；
- 生成 DOM 树，解析 css 和 js，渲染页面，直至显示完成；

## TCP 传输的三次握手、四次挥手策略

三次握手：
为了准确无误地吧数据送达目标处，TCP 协议采用了三次握手策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，他一定会向对方确认是否送达，握手过程中使用 TCP 的标志：SYN 和 ACK
发送端首先发送一个带 SYN 的标志的数据包给对方
接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息
最后，发送端再回传一个带 ACK 的标志的数据包，代表“握手”结束
如在握手过程中某个阶段莫明中断，TCP 协议会再次以相同的顺序发送相同的数据包
断开一个 TCP 连接需要“四次挥手”
第一次挥手：主动关闭方发送一个 FIN，用来关注主动方到被动关闭方的数据传送，也即是主动关闭方告诫被动关闭方：我已经不会再给你发数据了（在 FIN 包之前发送的数据，如果没有收到对应的 ACK 确认报文，主动关闭方依然会重发这些数据）。但是，此时主动关闭方还可以接受数据
第二次挥手：被动关闭方收到 FIN 包后，发送一个 ACK 给对方，确认序号收到序号 +1（与 SYN 相同，一个 FIN 占用一个序号）
第三次挥手：被动关闭方发送一个 FIN。用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会给你发送数据了
第四次挥手：主动关闭方收到 FIN 后，发送一个 ACK 给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手

## HTTP 和 HTTPS，为什么 HTTPS 安全

- HTTP 协议通常承载与 TCP 协议之上，在 HTTP 和 TCP 之间添加一个安全协议层（SSL 或 TSL），这个时候，就成了我们常说的 HTTPS
- 默认 HTTP 的端口号为 80，HTTPS 的端口号为 443
- 因为网络请求需要中间有很多的服务器路由的转发，中间的节点都可能篡改信息，而如果使用 HTTPS，密钥在你和终点站才有，https 之所有说比 http 安全，是因为他利用 ssl/tls 协议传输。包含证书，流量转发，负载均衡，页面适配，浏览器适配，refer 传递等，保障了传输过程的安全性

## HTTP 常见的状态码

1xx(临时响应)接收到请求并且继续处理
100 Continue 继续，一般在发送 post 请求时，已发送了 http header 之后服务端将返回此信息，表示确认，之后发送具体参数信息
101(切换协议) 请求者已要求服务器切换协议，服务器已确认并准备进行切换。

2xx(成功)
**200 OK 正常返回信息**
201 Created 请求成功并且服务器创建了新的资源
202 Accepted 服务器已接受请求，但尚未处理

3xx(已重定向)
301 Moved Permanently 请求的网页已永久移动到新位置。
302 Found 临时性重定向。
303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。
**304 Not Modified 自从上次请求后，请求的网页未修改过。(使用浏览器缓存)**

4xx(请求错误)
400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。
**401 Unauthorized 请求未授权。(没有提供认证信息。请求的时候没有带上 Token 等)**
**403 Forbidden 没有权限,禁止访问。**
**404 Not Found 请求的内容不存在。**

5xx(服务器错误)
500 Internal Server Error 最常见的服务器端错误。
501：请求还没有被实现。
503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。

## 中断 ajax 请求

- 设置超时时间让 ajax 自动断开，另一种是手动停止 ajax 请求，
- ajax.abort(),其核心是调用 XML 对象的 abort 方法

## get/post 的区别

1.get 传参方式是通过地址栏 URL 传递，是可以直接看到 get 传递的参数，post 传参方式参数 URL 不可见，get 把请求的数据在 URL 后通过？连接，通过&进行参数分割。psot 将参数存放在 HTTP 的包体内

2.get 传递数据是通过 URL 进行传递，对传递的数据长度是受到 URL 大小的限制，URL 最大长度是 2048 个字符。post 没有长度限制

3.get 后退不会有影响，post 后退会重新进行提交

4.get 请求可以被缓存，post 不可以被缓存

5.get 请求只 URL 编码，post 支持多种编码方式

6.get 请求的记录会留在历史记录中，post 请求不会留在历史记录

7.get 只支持 ASCII 字符，post 没有字符类型限制

## get 请求传参长度的误区、get 和 post 请求在缓存方面的区别

误区：我们经常说 get 请求参数的大小存在限制，而 post 请求的参数大小是无限制的。

实际上 HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 get 请求参数的限制是来源与浏览器或 web 服务器，浏览器或 web 服务器限制了 url 的长度。为了明确这个概念，我们必须再次强调下面几点:
HTTP 协议 未规定 GET 和 POST 的长度限制
GET 的最大长度显示是因为 浏览器和 web 服务器限制了 URI 的长度
不同的浏览器和 WEB 服务器，限制的最大长度不一样
要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte
**补充补充一个 get 和 post 在缓存方面的区别：**
get 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。
post 不同，post 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 get 请求适合于请求缓存。

## 常见跨域的解决办法

1. JSONP

```js
// JSONP 的原理很简单，就是利用  <script>  标签没有跨域限制的漏洞。通过  <script>  标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。
// JSONP 使用简单且兼容性不错，但是只限于 get 请求
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
  function jsonp(data) {
    console.log(data)
  }
</script>
```

2. CORS（Cross-Origin ResourceSharing）跨域资源共享
CORS背后的基本思想就是使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。 目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。 因为需要通过 XDomainRequest 来实现。
整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。
**实现CORS通信的关键是服务器**。只要服务器实现了CORS接口，就可以跨源通信。
服务器端对于CORS的支持，主要就是通过设置**Access-Control-Allow-Origin**来进行的

3.

<!-- [从服务器主动推送消息到客户端]
[浏览器跨域]
  JSONP跨域（本质是JS调用）
  CORS（后台设置）
  Nginx反向代理（运维配置）
[前端常见攻击方式]
  XSS攻击
  CSRF攻击
  Sql注入
  html脚本注入 -->

---

[🔺 顶部](#top) <a id="bottom">⚓</a>
